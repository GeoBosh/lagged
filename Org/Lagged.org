#+TITLE: Lagged objects in package 'lagged'
#+AUTHOR: Georgi N. Boshnakov
# #+STARTUP: hideblocks
#+PROPERTY: header-args:R  :session *R*
#+PROPERTY: header-args    :results silent
# #+PROPERTY: header-args:R  :tangle ../R/lagged.R  :comments both
#+PROPERTY: header-args:R  :tangle ../R/lagged.R
#+LATEX_CLASS: rpackagearticle

\vspace*{1cm}
This message is printed at the start of the tangled .R file to alert against editing that
file:
#+BEGIN_SRC R
## Do not edit this file manually.
## It has been automatically generated from *.org sources.
#+END_SRC

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
## Do not edit this file manually.
## It has been automatically generated from *.org sources.
#+END_SRC



* Class "Lagged"


"Lagged" is the base lagged class. It is virtual and defines a slot ~data~ from class
"ANY".
#+BEGIN_SRC R
setClass("Lagged", slots = c(data = "ANY"), contains = "VIRTUAL")
                               # setClass("Lagged", slots = c(data = "vector") )
                               # setClass("Lagged", slots = c(data = "structure") )
#+END_SRC

Actual classes inherit from "Lagged" and restrict the data slot.  
#+BEGIN_SRC R
                                               # setClass("X", slots = c(data = "structure"))
setClass("Lagged1d", contains = "Lagged", slots = c(data = "vector") )
setClass("Lagged2d", contains = "Lagged", slots = c(data = "matrix") )
setClass("Lagged3d", contains = "Lagged", slots = c(data = "array") )
                     # TODO: check validity for Lagged3d: 3 dimensional.
#+END_SRC
One special subclass of "Lagged" is "FlexibleLagged", which can represent objects from any
subclass of "Lagged". This is achieved by setting the data slot to be "Lagged" along with
methods for indexing, ~maxLag~, and similar to ensure that the Lagged functionality is
provided. (*NOTE (2019-05-15): adding prototype since the default is puzzling and leaves the
object invalid if slot ~data~ is not set during initialisation. In particular,
~new("FlexibleLagged")~, was returning an invalid object without warning nor error.)
#+BEGIN_SRC R
setClass("FlexibleLagged", contains = "Lagged", slots = c(data = "Lagged"),
         prototype = list(data = new("Lagged1d")) )
#+END_SRC
The initialisation method for "FlexibleLagged" objects does the obvious thing if argument
~data~ is "Lagged". Otherwise it converts argument ~data~ to a suitable "Lagged" object
before assigning it to the data slot. If the function is not able to infer a suitable
"Lagged" class it still passes ~data~ on to the next method which usually leads to an error.

The following convenience function is used to infer a suitable "Lagged" class for argument
~data~:
#+BEGIN_SRC R
.whichNativeLagged <- function(x){
    if(is(x, "Lagged"))
        "FlexibleLagged"
    else if(is.vector(x))
        "Lagged1d"
    else if(is.matrix(x))
        "Lagged2d"
    else if(is.array(x)  && length(dim(x)) == 3)
        "Lagged3d"
    else
        NA

}
#+END_SRC


This is the initialisation method for ="FlexibleLagged"=. Note that it gets rid of recursive
="FlexibleLagged"= data slots, i.e. the data slot of the returned object is "Lagged" but not
"FlexibleLagged".  *TODO:* This probably should be taken care of by a validation method.

*!!! 2019-05-15 Note:* Moving argument data after the ="..."= argument, so that it is matched
     only when explicitly supplied. Otherwise it makes it difficult to use unnamed arguments
     in initialisation of subclasses. The success may depend on the order of the arguments
     and the error message is not helpful. This change is potentially breaking change but it
     seems that ~data~ is always named in existing code.
#+BEGIN_SRC R
setMethod("initialize", "FlexibleLagged",
          function(.Object, ..., data){
              if(missing(data)){
                  res <- callNextMethod(.Object, ...)
                  return(res)
              }

              while(is(data, "FlexibleLagged"))
                  data <- data@data

              if(!is(data, "Lagged")){
                  clname <- .whichNativeLagged(data)
                  if(!is.na(clname))
                      data <- new(clname, data = data)
                  ##else don't know what to do with data, pass it on
                  ##     and let others complain if not appropriate.
              }
              .Object <- callNextMethod(.Object, data = data, ...)

              .Object
          }
          )
#+END_SRC
In general, "FlexibleLagged" can be used as superclass of classes which wish to represent any
possible subclasses of "Lagged". For slots, it is sufficient (and more efficient) to use
"Lagged".

Since class "FlexibleLagged" is special, it has its own implementations of some core methods
defined for "Lagged".

*TODO:* Decide what support to offer for the native S3 class "acf". Turn it into S4 using
~setOldClass~? Or just adapt the various methods and constructors to convert it properly to
Lagged? For now putting some code in ~Lagged()~ to accept "acf" objects.

** Core methods for lagged objects

The methods in this section are ok for objects inheriting from "Lagged". Where
necessary, specialised methods are defined for "FlexibleLagged".


*** Subscripting with "["

Subscripting with ~i~ missing, returns the raw data.
#+BEGIN_SRC R
setMethod("[", c(x = "Lagged", i = "missing"), function(x) x@data )
setMethod("[", c(x = "FlexibleLagged", i = "missing", j = "missing"), function(x) x@data[] )
setMethod("[", c(x = "FlexibleLagged", i = "missing", j = "ANY"), 
          function(x, i, j, ..., drop) x@data[ , j, ..., drop] )
#+END_SRC

When ~i~ is present, indexing depends on the type of the data slot and so is defined by
subclasses. For indices larger than ~maxLag(x)~ the values are filled with NA's.


*TODO:* consider making the 1d method the default one?

For "[", the default for ~drop~ is ~FALSE~.
*TODO:* check that the existing methods follow this convention!

Indexing "FlexibleLagged" simply transfers the operation to the data slot (it is "Lagged").
I created separate methods for ~drop~ since just omitting it from the method signature and setting
~drop = FALSE~ in the signature of the function seems to have no effect (and
~findMethods("FlexibleLagged")~ shows that the default for drop in the method is ~TRUE~).
#+BEGIN_SRC R
setMethod("[", c(x = "FlexibleLagged", i = "numeric", j = "missing", drop = "missing"), 
          function(x, i, ..., drop = FALSE){
#browser()
              if(nargs() == 2)
                  x@data[i] 
              else
                  x@data[i, ] 
          }
          )
setMethod("[", c(x = "FlexibleLagged", i = "numeric", j = "missing", drop = "logical"), 
          function(x, i, ..., drop = FALSE)
              if(nargs() == 3)
                  x@data[i, drop = drop] 
              else
                  x@data[i, , drop = drop] 
          )
#+END_SRC


*** Subscript-replacement with "[<-"

Similarly to "[", subscript-replacement "[<-" replaces the contents of the data.  The method
for "Lagged" does not check the validity of argument ~value~ but the assignment will
raise an error if it is not appropriate. Subclasses that wish to provide finer control over
this can define suitable methods (e.g. to coerce ~value~ appropriately).
#+BEGIN_SRC R
setReplaceMethod("[", c(x = "Lagged", i = "missing"),
          function(x, i, value){
              x@data <- value
              x
          })
#+END_SRC

Assignment to "FlexibleLagged", when ~i~ is missing, attempts to coerce ~value~ to a suitable
lagged class before assigning it (using ~.whichNativeLagged()~, as the initialisation
function does, but raising an error if unsuccessful). Further methods can be defined using
~"value = xxx"~ in the signature to accommodate additional types or overwrite the default
method here.
#+BEGIN_SRC R
setReplaceMethod("[", c(x = "FlexibleLagged", i = "missing"),
                 function(x, i, value){
                     if(is(value, "FlexibleLagged"))
                         x@data <- value@data
                     else if(is(value, "Lagged"))
                         x@data <- value
                     else{
                         clname <- .whichNativeLagged(value)
                         if(is.na(clname))
                             stop("Don't know what Lagged class to use for this value")
                         else
                             x@data <- new(clname, data = value) # as(value, clname)
                     }
                     x
                 })
#+END_SRC
When ~i~ is present, no attempt is made to coerce it:
#+BEGIN_SRC R
setReplaceMethod("[", c(x = "FlexibleLagged", i = "numeric"),
                 function(x, i, value){
                     x@data[i] <- value # not i+1, since x@data is a "Lagged" object here.
                     x
          })
#+END_SRC

#+BEGIN_SRC R
## Ne, tezi zasega ne gi pravya, pravya vischko bez "value = xxx" - tova pozvolyava da se
## definirat metodi ako tryabva.
##
## setReplaceMethod("[", c(x = "FlexibleLagged", i = "missing", value = "vector"),
##           function(x, i, value){
##               x@data <- as(value, "Lagged1d")
##               x
##           })
##
## setReplaceMethod("[", c(x = "FlexibleLagged", i = "missing", value = "matrix"),
##           function(x, i, value){
##               x@data <- as(value, "Lagged2d")
##               x
##           })
#+END_SRC


*** Methods for "[[" and "[[<-"

Indexing with "[[" returns the value for the specified lag. This is the recommended way to
extract the value at a single index.

This defines a default method. For efficiency specific classes can define versions that avoid
calling the generic "[[". If multi-seasons are supported the check for length equal to one
should be adapted accordingly.
#+BEGIN_SRC R
setMethod("[[", c(x = "Lagged", i = "numeric", j = "missing"),
          function(x, i, j){
              if(length(i) == 1)
                  x[i, drop = TRUE]
              else
                  stop("the length of argument `i' must be equal to one")
          }
          )

setMethod("[[", c(x = "FlexibleLagged", i = "ANY", j = "ANY"),
          function(x, i, j){
              x@data[[i, j]]
          }
          )
setMethod("[[", c(x = "FlexibleLagged", i = "missing", j = "numeric"),
          function(x, i, j){
              x@data[[ , j]]
          }
          )
setMethod("[[", c(x = "FlexibleLagged", i = "numeric", j = "missing"),
          function(x, i, j){
              if(nposargs(sys.call(-1)) == 2) # x[[i]]
                  x@data[[i]]
              else # x[i, ]
                  x@data[[i, ]]
          }
          )
#+END_SRC
Note the use of ~drop = TRUE~.
*TODO:* The use of ~drop = TRUE~ maybe needs some further thought. Maybe something that drops
only the index corresponding to the lag is preferable and such behaviour should be documented!

*Note:* After more thought, ~drop = TRUE~ is excellent for "[[" and could be used in more
    circumstances. 

The replace method works similarly:
#+BEGIN_SRC R
setReplaceMethod("[[", c(x = "Lagged", i = "numeric"),
                 function(x, i, value){
                     if(length(i) == 1)
                         x[i] <- value
                     else
                         stop("the length of argument `i' must be equal to one")
                     x
                 })
#+END_SRC


For "Lagged2d" define further methods. When ~j~ is present the indexing is matrix-like with
~drop = TRUE~. For now restrict this to the case when ~i~ is a single number (but ~j~ can be
a vector). 

*TODO:* It is probably imperative here to distinguish ~x[[i,] ]~ and ~x[[i] ]~
(but this should be done in the method with missing ~j~).
*Done:* Here ~nargs() can't distinguish ~x[i]~ and ~x[i,]~, roughly because ~sys.call()~ is
~.local(x, i, j, ...)~, due to the way S4 methods work. So I use ~nposargs()~. (*TODO:* think
about more efficient version of ~nposargs()~?)

Note that ~x[[i] ]~ is identical to ~x[[ , i] ]~. So, the second definition is technically
redundant. It is there for user's convenience and to avoid an obscure error message
(incidentally, it is currently somewhat more efficient).
#+BEGIN_SRC R
setMethod("[[", c(x = "Lagged2d", i = "numeric", j = "missing"),
          function(x, i, j){
              if(length(i) == 1){
                  if(nposargs(sys.call(-1)) == 2) # x[i] - note the use of -1 in sys.call()
                      x@data[ , i + 1, drop = TRUE]
                  else             # x[i, ]
                      x@data[i, , drop = TRUE]
              }else
                  stop("the length of argument `i' must be equal to one")
          }
          )
setMethod("[[", c(x = "Lagged2d", i = "missing", j = "numeric"),
          function(x, i, j){
              if(length(j) == 1){
                      x@data[ , j + 1, drop = TRUE]
              }else
                  stop("the length of argument `j' must be equal to one")
          }
          )
setMethod("[[", c(x = "Lagged2d", i = "numeric", j = "numeric"),
          function(x, i, j){
              if(length(i) == 1)
                  x@data[i, j + 1, drop = TRUE]
              else
                  stop("the length of argument `i' must be equal to one")
          }
          )
setMethod("[[", c(x = "Lagged2d", i = "numeric", j = "logical"),
          function(x, i, j){
              if(length(i) == 1)
                  x@data[i, j, drop = TRUE]
              else
                  stop("the length of argument `i' must be equal to one")
          }
          )
#+END_SRC





*** Arithmetic and other operations (Ops group)

Operations in the ~Ops~ group involving lagged objects are defined "naturally" on their
data. However, they are more restrictive than base R's conventions for atomic objects and do
not follow the recycling rules.

The binary "Ops" methods return values from one of the core lagged classes, even if the
objects are from classes inheriting from "Lagged". The reason is that, for example, the
difference between autocovariance functions is not necessarilly autocovariance, but it is
still a lagged object. It would be very confusing if the result was not guaranteed to be
"Lagged".  Also, if a policy of preserving the actual class were to be adopted, what would
be the rule for the class of the result from binary operations between lagged objects from
different classes (it seems not possible to have a simple one). 


Of course, methods defined for subclasses of lagged objects may preserve the actual classes
when appropriate but should not introduce confusion on indexing.

In the default methods below, the result of these operations is a strict lagged object,
i.e. an object from the core lagged classes (*TODO:* explain). The exact type of lagged
object is determined by the data. The net effect is that the value of the Ops operation is
also a lagged object, a core one, with indexing starting from zero but additional structure
is lost.


*TODO:* Should operations between "Lagged" and base R objects be permitted at all?  For users
of "Lagged" the returned "Lagged" value is natural and expected. But what about users who are
not aware that there are "Lagged" objects among the arguments? What to do when the "ordinary"
argument is of length one - should this be an exception? But then the user may not know that
the length is one, leading to surprises. Also, there is a conceptual difference here between
the additive and multiplicative operations. (All this should be documented in a vignette. It
seems sufficient that the recycling rule is banned. Need to finalise operation with
singletons.)


Operations between two lagged objects give a lagged object. If their ~maxLag()~ properties
are different, the shorter data slot is extended with NA's before applying the binary
operation.


**** "Ops" involving "Lagged"

The unary operators preserve the class of the object:
#+BEGIN_SRC R
setMethod("Ops", c(e1 = "Lagged", e2 = "missing"),
          function(e1){
                    # wrk <- callGeneric(e1@data)
                    # clname <- whichLagged(e1)
                    # new(clname, data = wrk)
              e1@data <- callGeneric(e1@data)
              e1
          })
#+END_SRC

#+BEGIN_SRC R
## TODO: do not allow mixing Lagged1d with Lagged2d, etc.?
setMethod("Ops", c(e1 = "Lagged", e2 = "Lagged"),
          function(e1, e2){
              wrk <- if(length(e1@data) == length(e2@data) ) # TODO: allow %%==0 as elsewhere?
                         callGeneric(e1@data, e2@data)
                     else{
                         maxlag <- max(maxLag(e1), maxLag(e2))
                         v1 <- e1[0:maxlag]
                         v2 <- e2[0:maxlag]
                         callGeneric(v1, v2)
                     }
              clname <- whichLagged(e1, e2)
              new(clname, data = wrk)
          })
#+END_SRC
*TODO:* the current mechanism to decide the lagged class of the return value is not very
satisfactory, see ~whichLagged()~ which encapsulates it. Also, forbid mixing 1d with 2d,
etc.?

When only one of the objects is "Lagged", the operations are defined if the following cases:

    1. the length of the other object is equal to the length of the data part of the "Lagged"
       object,
    2. the other object is of length one,
    3. the other object is a singleton with the same dimensions as a single element of the
       "Lagged" object.

*old todo:* document behaviour if ~length(object@data) == 0~ (minor issue)?

*2017-05-20 TODO:* Change ~length(e1[[0]]) == length(e2))~ below to
                   ~dim(e1[[0]]) == dim(e2))~ but needs more care (note though that the
                   scalar case is covered by ~length(e2) == 1~.

Notice that "vector" in the signatures is the S4 class "vector" (TODO: check!), see
~showClass("vector")~ for its subclasses.
#+BEGIN_EXAMPLE
> is.vector(array(0, dim = c(2,2,2)))    # S3
[1] FALSE

> is(array(0, dim = c(2,2,2)), "vector") # S4
[1] TRUE
#+END_EXAMPLE


#+BEGIN_SRC R
setMethod("Ops", c(e1 = "Lagged", e2 = "vector"),
          function(e1, e2){
              wrk <- if(length(e2) == 1  || length(e1@data) == length(e2)
                             # 2017-05-20 was:
                             #    || length(e2) > 0  && (length(e1@data) %% length(e2)) == 0
                        || length(e2) > 0  && length(e1[[0]]) == length(e2))
                         callGeneric(e1@data, e2)
                     else
                         stop("Incompatible length of operands in a binary operation")

              new(whichLagged(e1), data = wrk)
          })

setMethod("Ops", c(e1 = "vector", e2 = "Lagged"),
          function(e1, e2){
              wrk <- if(length(e1) == 1  || length(e1) == length(e2@data)
                             # 2017-05-20 was:
                             #    || length(e1) > 0  && (length(e2@data) %% length(e1)) == 0
                        || length(e1) > 0  && length(e2[[0]]) == length(e1))
                         callGeneric(e1, e2@data)
                     else
                         stop("Incompatible length of operands in a binary operation")

              new(whichLagged(e2), data = wrk)
          })
#+END_SRC


**** "Ops" involving "FlexibleLagged"

Operations involving "FlexibleLagged" objects use those defined for "Lagged" by operating on
the data slot (which is "Lagged").
#+BEGIN_SRC R
setMethod("Ops", c(e1 = "FlexibleLagged", e2 = "Lagged"),
          function(e1, e2){
              callGeneric(e1@data, e2)
          })

setMethod("Ops", c(e1 = "Lagged", e2 = "FlexibleLagged"),
          function(e1, e2){
              callGeneric(e1, e2@data)
          })

setMethod("Ops", c(e1 = "FlexibleLagged", e2 = "FlexibleLagged"),
          function(e1, e2){
              callGeneric(e1@data, e2@data)
          })


setMethod("Ops", c(e1 = "FlexibleLagged", e2 = "vector"),
          function(e1, e2){
              callGeneric(e1@data, e2)
          })

setMethod("Ops", c(e1 = "vector", e2 = "FlexibleLagged"),
          function(e1, e2){
              callGeneric(e1, e2@data)
          })
#+END_SRC

*TODO:* methods for "matrix", "array", these probably should be for specific "Lagged"
subclasses, like "Lagged2d".


*** "Math" and "Math2" group methods

"Math" and "Math2" methods return the object with its data part transformed by the
corresponding function. 

*TODO:* Does this work for ~FlexibleLagged~?
#+BEGIN_SRC R
setMethod("Math", c(x = "Lagged"),
          function(x){
              x@data <- callGeneric(x@data)
              x
          })
#+END_SRC


#+BEGIN_SRC R
setMethod("Math2", c(x = "Lagged"),
          function(x, digits){
              x@data <- callGeneric(x@data, digits)
              x
          })
#+END_SRC


*** "Summary" group methods

The "Summary" methods operate on the data part of the "Lagged" object.
#+BEGIN_SRC R
setMethod("Summary", c(x = "Lagged"),
          function(x, ..., na.rm = FALSE){
              callGeneric(x@data)
          })
#+END_SRC


** S3 methods for as.vector() and related functions for "Lagged"

#+BEGIN_SRC R
## TODO: check if the S3 methods understand S4 inheritance (I think they do)
as.vector.Lagged <- function(x, mode) as.vector(x@data) # todo: use mode?
as.double.Lagged <- function(x, ...)  as.double(x@data ) # note: this is for as.numeric()
as.matrix.Lagged <- function(x, ...)  as.matrix(x@data)
 as.array.Lagged <- function(x, ...)  as.array(x@data)
#+END_SRC
Converting from "Lagged" to base atomic or structure objects applies the requested
operation to the data slot. Define first the generic S3 methods:

Somewhat more efficient methods for these:
#+BEGIN_SRC R
as.vector.Lagged1d <- function(x, mode) x@data
as.matrix.Lagged2d <- function(x, ...) x@data
as.array.Lagged3d  <- function(x, ...) x@data
#+END_SRC


** setAs() methods for "Lagged"

These methods call the corresponding S3 methods defined above:
#+BEGIN_SRC R
setAs("Lagged", "vector", function(from) as.vector(from) )
setAs("Lagged", "matrix", function(from) as.matrix(from) )
setAs("Lagged", "array",  function(from) as.array(from) )
#+END_SRC



** Generic function maxLag()

The default method for =maxLag()= handles objects inheriting from S3 class "acf". In all
other cases it raises an error. Notice that in "acf" the lag is in the first dimension.
#+BEGIN_SRC R
maxLag <- function(object, ...){
   if(inherits(object, "acf"))
       dim(object$acf)[1] - 1
   else
       stop("No applicable method to compute maxLag")
}

setGeneric("maxLag")
#+END_SRC

#+BEGIN_SRC R
setGeneric("maxLag<-", def = function(object, ..., value){ standardGeneric("maxLag<-") } )
#+END_SRC

*TODO:* Do we need a separate method for "FlexibleLagged"?
*Answer (2015-05-16): Yes!
#+BEGIN_SRC R
setReplaceMethod("maxLag", "Lagged",
                 function(object, ..., value){
                     object@data <- object[0:value]
                     object
                 }
                 )

setReplaceMethod("maxLag", "FlexibleLagged",
                 function(object, ..., value){
                     maxLag(object@data) <- value
                     object
                 }
                 )
#+END_SRC

The convention for "Lagged" objects is that the last dimension carries the lag.  So, the
methods for basic objects compute the maximal lag as the last dimention minus one.
#+BEGIN_SRC R
setMethod("maxLag", c(object = "vector"), function(object) length(object) - 1)
setMethod("maxLag", c(object = "matrix"), function(object) ncol(object) - 1 )
setMethod("maxLag", c(object = "array"),
          function(object){
                  d <- dim(object)
                  d[length(d)] - 1
          })
#+END_SRC
Note again that =acf()= puts the lag in the first index.

The ~maxLag()~ method for "Lagged" objects simply calls ~maxLag()~ on the data slot. Classes
inheriting from "Lagged" may define specific methods if the (in)efficiency of this method is
a concern.
#+BEGIN_SRC R
setMethod("maxLag", c(object = "Lagged"), function(object) maxLag(object@data) )
#+END_SRC


** Length of "Lagged" objects - S3 method for length()

The length of "Lagged" objects is defined to be =maxLag(x)+1=, not the length of the data in
the "Lagged" object. In most cases of direct use =maxLag(x)= is more appropriate.

This defines an S3 method for function ~length()~ for "Lagged" objects.
#+BEGIN_SRC R
length.Lagged <- function(x) maxLag(x) + 1
#+END_SRC

*TODO:* Check if other base R functions need S3 methods for "Lagged" objects.




* Methods for "["

#+BEGIN_SRC R
setMethod("[", c(x = "Lagged1d", i = "numeric"),
          function(x, i, drop) x@data[i+1] )
#+END_SRC


*TODO:* Don't give option to change argument ~drop~ and raise error if it is present?

*TODO:* Currently silently ignores argument ~j~. Throw error if it is present?
    Another alternative is to define the current methods with ~j = "missing"~ but then
    explicit methods for "ANY" will be needed to avoid some other method matching quietly and
    doing something even less relevant.

*TODO:* For ="Lagged2d"=, add argument ~type~ to accommodate indexing like ="slMatrix"=.
    Need some thought to streamline that old stuff. However, it may be better not to put this on
    ="Lagged2d"= but introduce subclass, say ="LaggedSL" of ="Lagged2d"= and define modified
    methods for that, streamlining in the process.
    (*NOTE:* mostly done, see below.)   

2019-05-18: New "[" methods for "Lagged2d". Decided to use argument ~drop~ for the argument
corresponding to ~type~ in "slMatrix". 

2019-05-25: Decided eventually to handle the difference between ~x[i]~ and ~x[i,]~, since
otherwise confusion arises.  Both go to the methods with ~j~ missing. The complete solution
is with ~gbutils::nposargs()~). It is used when drop is logical. When drop is missing, it is
sufficient to use ~nargs()~ and avoid additional overhead for the most common case, ~x[i]~.
#+BEGIN_SRC R
setMethod("[", c(x = "Lagged2d", i = "numeric", j = "missing", drop = "missing"),
          function(x, i, ..., drop = FALSE){
              if(nargs() == 2)              # x[i]
                  x@data[ , i+1, drop = FALSE] 
              else                          # x[i, ]
                  x@data[i, , drop = FALSE] 
          }
          )

setMethod("[", c(x = "Lagged2d", i = "numeric", j = "missing", drop = "logical"),
          function(x, i, ..., drop = FALSE){
              if(nposargs(sys.call()) == 2) # x[i]
                  x@data[ , i+1, drop = drop]
              else                          # x[i, ]
                  x@data[i, , drop = drop]
          } 
          )
#+END_SRC

2020-03-02 Adding methods for character ~i~ for ="Lagged2d"= with the same semantics as the
above ="numeric"= methods. 
#+BEGIN_SRC R
setMethod("[", c(x = "Lagged2d", i = "character", j = "missing", drop = "missing"),
          function(x, i, ..., drop = FALSE){
              if(nargs() == 2)              # x[i]
                  ## no need (and can't) to add one here
                  x@data[ , i, drop = FALSE] 
              else                          # x[i, ]
                  x@data[i, , drop = FALSE] 
          }
          )

setMethod("[", c(x = "Lagged2d", i = "character", j = "missing", drop = "logical"),
          function(x, i, ..., drop = FALSE){
              if(nposargs(sys.call()) == 2) # x[i]
                  x@data[ , i, drop = drop]
              else                          # x[i, ]
                  x@data[i, , drop = drop]
          } 
          )
#+END_SRC


Non-missing ~j~. 
#+BEGIN_SRC R
setMethod("[", c(x = "Lagged2d", i = "numeric", j = "numeric", drop = "missing"),
          function(x, i, j, ..., drop = FALSE)  
              x@data[i, j + 1, drop = FALSE]
          )
setMethod("[", c(x = "Lagged2d", i = "missing", j = "numeric", drop = "missing"),
          function(x, i, j, ..., drop = FALSE)  
              x@data[ , j + 1, drop = FALSE]
          )
#+END_SRC

#+BEGIN_SRC R
setMethod("[", c(x = "Lagged2d", i = "character", j = "numeric", drop = "missing"),
          function(x, i, j, ..., drop = FALSE)  
              x@data[i, j+1, drop = FALSE]
          )
setMethod("[", c(x = "Lagged2d", i = "character", j = "character", drop = "missing"),
          function(x, i, j, ..., drop = FALSE)  
              x@data[i, j, drop = FALSE]
          )
setMethod("[", c(x = "Lagged2d", i = "numeric", j = "character", drop = "missing"),
          function(x, i, j, ..., drop = FALSE)  
              x@data[i, j, drop = FALSE]
          )
setMethod("[", c(x = "Lagged2d", i = "missing", j = "character", drop = "missing"),
          function(x, i, j, ..., drop = FALSE)  
              x@data[ , j, drop = FALSE]
          )
#+END_SRC




This implements (part of?) the functionality of "slMatrix" indexing. I decided to 
use argument ~drop~, even though it is generally not a good idea to overload an argument
designed for another purpose. However, from a more general perspective, ~drop~ controls the
shape of the result. 
#+BEGIN_SRC R
setMethod("[", c(x = "Lagged2d", i = "ANY", j = "ANY", drop = "character"),
          ## very old code, modelled after the method for 'slMatrix'
          function(x, i, j, ..., drop = "sl"){  
              ## for now, don't write about this method in the documentation;
              ## it will certainly change

              y <- x@data
              period <- nrow(y)
              if(missing(i))
                  i <- 1:nrow(y)
              if(missing(j))
                  j <- 0:maxLag(x)

              ## TODO: should set 'drop = FALSE' when extracting below but keep it for now in
              ##    case old code depends on the current. In particular this is almost
              ##    certainly so when extracting single values.
              switch(drop,
                     ## "sl" is for completeness, it is the default without this method
                     "sl" = {
                         season <- i
                         lag <- pc.omitneg(j, ncol(x)-1)
                         res <- y[season, lag+1]   # lag+1 because lags start from zero
                     },
                     "tt" = {
                         res <- myouter(i, j, function(ii, jj){
                             wrk <- toSeasonPair(ii, jj, period)
                             season <- wrk$season
                             lag <- wrk$lag
                             y[season, lag + 1]
                         }
                         )
                     },
                     "tl" = {
                         season <- toSeason(i, period)
                         lag <- j
                         res <- y[season, lag + 1]      # lag+1 because lags start from zero.
                     },
                     "tl+-" = {
                         if(length(j) == 1){
                             if(j>=0){                   # this works only for scalar  j
                                 season <- toSeason(i, period)
                                 lag <- j
                             }else{
                                 season <- toSeason(i - j, period)
                                 lag <- -j
                             }
                             res <- y[season, lag+1] # lag+1 because lags start from zero.
                         }else{
                             res <- matrix(NA, nrow = length(i), ncol = length(j))
                             for(k in 1:length(j)){
                                 if(j[k] >= 0){         # this works only for scalar  j
                                     season <- toSeason(i, period)
                                     lag <- j[k]
                                 }else{
                                     season <- toSeason(i - j[k], period)
                                     lag <- -j[k]
                                 }
                                 res[ , k] <- y[season, lag+1]#lag+1 as lags start from zero.
                             }
                         }
                     },
                     "t+l,l+-" = {
                         res <- matrix(NA, nrow = length(i), ncol = length(j))
                         for(k in 1:length(j)){
                             res[ , k] <- x[i + j[k], j[k], drop = "tl+-"]
                         }
                     },
                     ## 2016-01-01 TODO: case "co" seems to be meant for j - scalar.
                     "co" = {
                         season <- toSeason(i, period)
                         lag <- j
                         if(lag < 0 || lag > maxLag(x) )
                             res <- 0
                         else{
                             res <- y[season, lag + 1] # lag+1 because lags start from zero.
                         }
                     },
                     stop("Invalid arg. type, must be one of \"sl\", \"tt\" or \"tl\".")
                     )
              res
          }
          )
#+END_SRC


#+BEGIN_SRC R
setMethod("[", c(x = "Lagged3d", i = "numeric", j = "missing", drop = "missing"),
          function(x, i, ..., drop = FALSE) x@data[, , i+1, drop = FALSE] )
setMethod("[", c(x = "Lagged3d", i = "numeric", j = "missing", drop = "logical"),
          function(x, i, ..., drop = FALSE) x@data[, , i+1, drop = drop] )
#+END_SRC

** whichLagged()

For now ~whichLagged()~ is not exported. It could be exported to allow core "Lagged" classes
defined in other packages to add functionality. But if it is to be exported, it would need
streamlining. Currently it is a hack.

Making it generic is lazy but avoids writing obscure code but see note above.
The default returns "FlexibleLagged".
#+BEGIN_SRC R
.matLagged <- matrix("FlexibleLagged", 4, 4)
diag(.matLagged) <- c("FlexibleLagged", "Lagged1d", "Lagged2d", "Lagged3d")

rownames(.matLagged) <- c("FlexibleLagged", "Lagged1d", "Lagged2d", "Lagged3d")
colnames(.matLagged) <- c("FlexibleLagged", "Lagged1d", "Lagged2d", "Lagged3d")


whichLagged <- function(x, y){
    .matLagged[whichLagged(x), whichLagged(y)]
}
setGeneric("whichLagged")
#+END_SRC

#+BEGIN_SRC R
## TODO: define methods for "numeric", "matrix", etc?
setMethod("whichLagged", c(x = "ANY"     , y = "missing"), function(x) "FlexibleLagged")
setMethod("whichLagged", c(x = "Lagged1d", y = "missing"), function(x) "Lagged1d")
setMethod("whichLagged", c(x = "Lagged2d", y = "missing"), function(x) "Lagged2d")
setMethod("whichLagged", c(x = "Lagged3d", y = "missing"), function(x) "Lagged3d")
#+END_SRC


** Methods for "[<-"

Missing index is equivalent to replacing all data: 
#+BEGIN_SRC R
setReplaceMethod("[", c(x = "Lagged", i = "missing"),
          function(x, i, value){
              x[0:maxLag(x)] <- value
              x
          })
#+END_SRC
The above method just calls "[<-" again, so it applies to any lagged objects.

The methods which work on the data, need to know their layout, so we need several methods.
#+BEGIN_SRC R
setReplaceMethod("[", c(x = "Lagged1d", i = "numeric"),
          function(x, i, value){
              x@data[i+1] <- value
              x
          })

setReplaceMethod("[", c(x = "Lagged2d", i = "numeric"), #Include value = "matrix" in signature?
          function(x, i, value){
              x@data[ , i+1]  <- value
              x
          })

## Include value = "array" in the signature? Will still need to check the dimensions
setReplaceMethod("[", c(x = "Lagged3d", i = "numeric"),
          function(x, i, value){
                      # was: x@data[i+1, , ]  <- value
              x@data[ , , i+1]  <- value
              x
          })
#+END_SRC




* show() methods

#+BEGIN_SRC R
## .printVecOrArray <- function(x){
##     if(is.vector(x)){
##         if(is.null(names(x)) || length(names(x)) == 0)
##             names(x) <- paste0("Lag_", 0:(length(x) - 1))
##         print(x)
##     }else if(is.matrix(x)){
##         ## TODO:
##         print(x)
##     }else if(is.array(x)){
##         ## TODO:
##         print(x)
##     }else
##         print(x)
## }
#+END_SRC


#+BEGIN_SRC R
setMethod("show", "Lagged1d",
          function(object){
              .reportClassName(object, "Lagged1d")
              cat("Slot *data*:", "\n")

              ## 2017-05-24 was:
              ##     x <- object@data
              ##     if(is.null(names(x)) || length(names(x)) == 0)
              ##         names(x) <- paste0("Lag_", 0:(length(x) - 1))
              x <- dataWithLagNames(object)
              print(x)
              ## cat("\n")
          }
          )
#+END_SRC

#+BEGIN_SRC R
setMethod("show", "Lagged2d",
          function(object){
              .reportClassName(object, "Lagged2d")
              cat("Slot *data*:", "\n")

              x <- dataWithLagNames(object)
              print(x)
              ## cat("\n")
          }
          )
#+END_SRC


#+BEGIN_SRC R
setMethod("show", "Lagged3d",
          function(object){
              .reportClassName(object, "Lagged3d")
              cat("Slot *data*:", "\n")

              ## x <- object@data
              ## if(is.null(dimnames(x)) || length(dimnames(x)) == 0){
              ##     d <- dim(x)
              ##     dimnames(x) <- list(rep("", d[1]), rep("", d[2]),
              ##                         paste0("Lag_", 0:(d[3] - 1)) )
              ## }
              x <- dataWithLagNames(object)
              print(x)
              ## cat("\n")
          }
          )
#+END_SRC

#+BEGIN_SRC R
## Commenting out since causes trouble by precluding default methods from printing.
##
## setMethod("show", "Lagged",
##           function(object){
##               ## .reportClassName(object, "Lagged") # this is silly: never writes!
##               ## callNextMethod()
##               wrk <- object@data
##               cat("Slot *data*:", "\n")
##               .printVecOrArray(wrk)
##               cat("\n")
##               ## callNextMethod() # in case the object inherits from other classes
##               ##                  # unfortunately, it prints slot data again.
##           }
##           )

setMethod("show", "FlexibleLagged",
          function(object){
              .reportClassName(object, "FlexibleLagged")
              cat("Slot *data*:", "\n")
              show(object@data)
          }
          )
#+END_SRC


* Further constructors for lagged objects

Function ~new()~ can be used to create objects from the lagged classes.
In this section we define some functions to make this more convenient.

First, a function to convert objects from S3 class "acf" (created by ~acf()~) to "Lagged":
#+BEGIN_SRC R
acf2Lagged <- function(x){
    acv <- x$acf
    d <- dim(acv)
    if(d[2] == 1 && d[3] == 1){
        data <- as.vector(acv)
        if(x$type == "partial") # lag-0 is missing, insert it
            data <- c(1, data)
        new("Lagged1d", data = data)
    }else{
        ## transpose to make the 3rd index corresponding to lag.
        ##   (taken from acfbase2sl() in package pcts, see the comments there)
        ##
        ## TODO: test!
        ## Note: in pcts:::acfbase2sl() the analogous command is aperm(acv, c(3,2,1))
        ##       i.e. R[k] is transposed => check if that is correct!
        data <- aperm(acv, c(2, 3, 1))

        if(x$type == "partial"){ # lag-0 is missing, insert it
            datanew <- array(NA_real_, dim(data) + c(0,0,1) )
            datanew[ , , -1] <- data
            data <- datanew
        }

        new("Lagged3d", data = data)
    }
}
#+END_SRC


Function "Lagged" looks at the supplied data argument and chooses an appropriate class
inheriting from "Lagged". *TODO:* Make ~Lagged()~ generic?
#+BEGIN_SRC R
Lagged <- function(data, ...){
    if(is.vector(data)){
        new("Lagged1d", data = data, ...)
    }else if(is.matrix(data)){
        new("Lagged2d", data = data, ...)
    }else if(is.array(data)){
        new("Lagged3d", data = data, ...)
    }else if(is(data, "Lagged")){
        new("FlexibleLagged", data = data, ...)
    }else if(inherits(data, "acf")){    # for S3 class "acf"
        acf2Lagged(data)
    }else
        stop("I don't know how to create a Lagged object from the given data")
}
#+END_SRC

*TODO:* Tests!


* New

The functions in this section are temporarily here during development and should be move to
more appropriate places eventually.

**

provideDimnames is new in R-3.0.0

=dataWithLagNames(object)= is a convenience function which works like
=object[]= but also ensures that the lag dimension has names. It is exported for use in other
packages. Occasionally users may wish to use it too.
#+BEGIN_SRC R
dataWithLagNames <- function(object, prefix = "Lag_"){
    x <- object[]
    if(length(x) == 0)
        return(x)

    if(is.array(x)){
        d <- dim(x)
        nd <- length(d)

        xwithnams <- provideDimnames(x, base = list(""), unique = FALSE)
        dimnames(xwithnams)[[nd]] <- paste0(prefix, 0:(d[nd] - 1))
        xwithnams
    }else{
        if(is.null(names(x)) || length(names(x)) == 0)
            names(x) <- paste0(prefix, 0:(length(x) - 1))
        x
    }
}
#+END_SRC






* Tests

** Indexing for lagged classes

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
test_that("Lagged classes: indexing",
{
#+END_SRC


*** Lagged1d

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R

    ## Lagged1d
    v <- 1:12
    v_lagged <- Lagged(v)
    expect_identical(v_lagged, new("Lagged1d", data = v))
    expect_equal(v_lagged[0:2], v[1:3])
    expect_equal(v_lagged[[0]], 1)
    expect_equal(v_lagged[0],   v_lagged[0, drop = FALSE])
    expect_equal(v_lagged[[0]], v_lagged[0, drop = TRUE])

    expect_equal(Lagged(1:4) + Lagged(1:2), Lagged(c(2, 4, NA, NA)))

    expect_equal(Lagged(1:4) + 1:4, Lagged(1:4 + 1:4))
    expect_equal(Lagged(1:4) + 1, Lagged(1:4 + 1))
    expect_error(Lagged(1:4) + 1:2, "Incompatible length of operands in a binary operation")

    vA_lagged <- v_lagged
    vA_lagged[] <- 3
    
#+END_SRC

** Lagged2d

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
    ## Lagged2d
    m1 <- m <- matrix(1:12, nrow = 4)
    rownames(m1) <- LETTERS[1:4]
    colnames(m1) <- paste0("Lag_" , 0:2)


    m1_lagged <- Lagged(m1)
    expect_identical(m1_lagged["Lag_0"], m1_lagged[ , "Lag_0"])
    expect_identical(m1_lagged[1, "Lag_0"], m1_lagged["A", "Lag_0"])
    expect_identical(m1_lagged[1, ], m1_lagged["A", ])
    ## m1["A", drop = FALSE] - this is ambiguous is it m1["A", ] or m1["A"] with drop = FALSE?
    m1_lagged["A", , drop = FALSE] # this is clear

    expect_identical(m1_lagged["A", "Lag_0"], m1_lagged["A", 0])

    m_lagged <- Lagged(m)
    expect_identical(m_lagged, new("Lagged2d", data = m))
    expect_equal(dim(m_lagged[0]), c(4, 1))
    expect_equal(m_lagged[0], m[ , 1, drop = FALSE])

    expect_null(dim(m_lagged[[0]]))
    expect_equal(m_lagged[[0]], m[ , 1, drop = TRUE])
    expect_equal(m_lagged[0],   m_lagged[0, drop = FALSE])
    expect_equal(m_lagged[[0]], m_lagged[0, drop = TRUE])

    m_laggedA <- m_lagged
    m_laggedA[[1]] <- 15:18
    expect_equal(m_laggedA[[1]], 15:18)
    expect_equal(m_laggedA[1], matrix(15:18, ncol = 1))

    tmp <- m_lagged
    expect_error(tmp[[1:2]] <- 15:18, "the length of argument .i. must be equal to one")

    as.matrix(m_lagged)
    ## Math
    co <- 10 + cos(m_lagged)
    ## Math2
    ceiling(co)
    floor(co)
    trunc(co)
    round(co, 3)
    signif(co, 3)

    mm <- matrix(10:49, nrow = 4, byrow = TRUE)
    mm_lagged <- Lagged(mm)

    as.matrix(mm_lagged)

    ## one index: lag
    expect_equal(ncol(mm_lagged[0]), 1)   # column vector
    expect_null(dim(mm_lagged[[0]]))      # numeric
    ## two indices: first is row, second is lag
    expect_true(!is.null(mm_lagged[1, 0]))     # '[' doesn't drop dimensions
    expect_true(!is.null(mm_lagged[1, 0:3]))

    expect_null(dim(mm_lagged[[1, 0]]  )) # '[[' does drop dimensions
    expect_null(dim(mm_lagged[[1, 0:3]]))
    expect_null(dim(m_lagged[[1, TRUE]])) # the whole first row, as numeric

    expect_true(!is.null(mm_lagged[1:2, 0:3])) # ok, a matrix
    ## but the first arg. of '[[' must be of length one, so this throws error:
    expect_error(mm_lagged[[1:2 , 0:3]], "the length of argument `i' must be equal to one")

    expect_identical(mm_lagged[[0]], mm_lagged[[ , 0]])
    expect_error(mm_lagged[[ , 0:3]], "the length of argument `j' must be equal to one")

    mm_lagged[ , 2]  # matrix with one column
    mm_lagged[ , 2:3]    

    ## currently no "[" method for "logical"
    ## TODO: maybe add one for symmetry with '[['?
    expect_error(m_lagged[1, TRUE])

    ## TODO: put expectations here:
    mm_lagged[1:4,1:4, drop = "sl"] # "sl" is the default, covered by  drop = "missing"
    mm_lagged[1:4,1:4, drop = "tt"]
    mm_lagged[1:4,1:4, drop = "tl"]
    expect_error(mm_lagged[1:4,1:4, drop = "dummy"], "Invalid arg. type, must be one of")
    mm_lagged[5:12, 1, drop = "tl+-"]
    mm_lagged[6:13, 1:4, drop = "tl+-"]
    mm_lagged[1, 4, drop = "co"]   # TODO: "co" may be worth a class
    mm_lagged[2, -1, drop = "co"]
    mm_lagged[2, 0, drop = "co"]
    mm_lagged[2, 9, drop = "co"]
    mm_lagged[2, 10, drop = "co"]
    mm_lagged[ 1:2, 4, drop = "co"] # 14 24
    mm_lagged[ 1:6, 4, drop = "co"] # 14 24 34 44 14 24
    mm_lagged[ 1:6, 0, drop = "co"] # 14 24 34 44 14 24

    mmm_lagged <- Lagged(mm)
    mmm_lagged[[1]]
    mmm_lagged[[1, TRUE]]
    mmm_lagged[[1, c(TRUE, FALSE)]]
    expect_error(mmm_lagged[[1:2, c(TRUE, FALSE)]], "the length of argument `i' must be equal to one")
#+END_SRC

*** Lagged3d

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
    ## Lagged3d
    a <- array(1:24, dim = c(2, 3, 4))
    a_lagged <- Lagged(a)
    expect_equal(whichLagged(a_lagged), "Lagged3d")

    expect_identical(a_lagged, new("Lagged3d", data = a))
    expect_equal(dim(a_lagged[0]), c(2,3,1) ) # c(dim(a)[-3], 1) )
    expect_equal(a_lagged[0], a[ , , 1, drop = FALSE])

    expect_equal(dim(a_lagged[[0]]), c(2,3) ) # dim(a)[-3]
    expect_equal(a_lagged[[0]], a[ , , 1, drop = TRUE])
    expect_equal(a_lagged[0],   a_lagged[0, drop = FALSE])
    expect_equal(a_lagged[[0]], a_lagged[0, drop = TRUE])

    as.array(a_lagged)

    ## as above for "FlexibleLagged"
    v_flex <- new("FlexibleLagged", data = v)
    expect_identical(v_flex@data, v_lagged)
    expect_equal(v_flex[0], v_lagged[0])
    expect_equal(v_flex[[0]], v_lagged[[0]])
    expect_equal(v_flex[0],   v_flex[0, drop = FALSE])
    expect_equal(v_flex[[0]], v_flex[0, drop = TRUE])

    maxLag(v_flex)
    expect_equal(whichLagged(v_flex), "FlexibleLagged")

    expect_equal(v_flex[], v)
    v_flex2 <- v_flex
    v_flex2[3:4] <- 0
    expect_equal(v_flex2[], c(v[1:3], 0, 0, v[6:12]))

    v_flex2[] <- v_flex
    v_flex2[] <- v_flex@data
    expect_error(v_flex2[] <- array(1, dim = c(2,2,2,2)), "Don't know what Lagged class to use for this value")

    v_flex3 <- v_flex
    v_flex3[] <- 1:5
    expect_equal(v_flex3[], 1:5) # length changes

    v_flex3[[1]]
    expect_error(v_flex3[[c(1,2)]], "the length of argument `i' must be equal to one")

    v_flex3      + v_flex3
    v_flex3@data + v_flex3
    v_flex3      + v_flex3@data
    v_flex3 + 1
    1 + v_flex3
    round(v_flex3)
    max(v_flex3)

    as.numeric(v_flex3)
    as.numeric(v_flex3@data)

    as.array(v_flex3)
    as.array(v_flex3@data)

    as.vector(v_flex3@data)
    as.vector(v_flex3)

    ## the data part is 1d here, so this gives error:
    expect_error(v_flex3[[1, 2]], "incorrect number of subscripts")
    m4_3 <- matrix(1:12, nrow = 4)
    m4_3fl <- Lagged(m4_3)
    expect_equal(Lagged(m4_3)[[1, 2]], m4_3[1, 3]) # second index is lag
    expect_equal(-(-Lagged(m4_3)), Lagged(m4_3)) # unary -
    expect_equal(Lagged(m4_3) + Lagged(m4_3), 2 * Lagged(m4_3))

    as.vector(m4_3fl)
    as.matrix(m4_3fl)
    expect_equal(maxLag(m4_3fl),2)
    maxLag(m4_3fl) <- 1

    m_flex <- new("FlexibleLagged", data = m)
    expect_identical(m_flex@data, m_lagged)
    expect_equal(m_flex[0], m_lagged[0])
    expect_equal(m_flex[[0]], m_lagged[[0]])
    expect_equal(m_flex[0],   m_flex[0, drop = FALSE])
    expect_equal(m_flex[[0]], m_flex[0, drop = TRUE])

    a_flex <- new("FlexibleLagged", data = a)
    expect_identical(a_flex@data, a_lagged)
    expect_equal(a_flex[0], a_lagged[0])
    expect_equal(a_flex[[0]], a_lagged[[0]])
    expect_equal(a_flex[0],   a_flex[0, drop = FALSE])
    expect_equal(a_flex[[0]], a_flex[0, drop = TRUE])

    expect_equal(a_flex[0, ],   a_flex[0, , drop = FALSE])



    ## maxLag, maxLag<-
    ##    TODO: extending with "maxLag<-"()

    expect_equal(maxLag(v_lagged), 11)
    expect_equal(maxLag(m_lagged), 2)
    expect_equal(maxLag(a_lagged), 3)

    v2_lagged <- v_lagged
    maxLag(v2_lagged) <- 2
    expect_equal(maxLag(v2_lagged), 2)
    expect_equal(v2_lagged[], v[1:3])

    v2_lagged[1]
    v2_lagged[1, drop = TRUE]
    v2_lagged[1, drop = FALSE]
    v2_lagged[1,]
    v2_lagged[1, , drop = TRUE]
    v2_lagged[1, , drop = FALSE]

    v2_lagged[ , 1]

    m2_lagged <- m_lagged
    maxLag(m2_lagged) <- 2
    expect_equal(maxLag(m2_lagged), 2)
    expect_equal(m2_lagged[], m[, 1:3])

    a2_lagged <- a_lagged
    maxLag(a2_lagged) <- 2
    expect_equal(maxLag(a2_lagged), 2)
    expect_equal(a2_lagged[], a[, , 1:3])

    maxLag(acf(AirPassengers))
    expect_error(maxLag(sin), "No applicable method to compute maxLag")
#+END_SRC

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
})
#+END_SRC

** .whichNativeLagged

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
test_that(".whichNativeLagged is ok",
{
    expect_identical(.whichNativeLagged(1:3), "Lagged1d")
    expect_identical(.whichNativeLagged(1:3 / 4), "Lagged1d")

    expect_identical(.whichNativeLagged(matrix(1:12, 4)), "Lagged2d")
    expect_identical(.whichNativeLagged(array(1:24, dim = c(4,3,2))), "Lagged3d")

    ## TODO: was this really the intent of this function (for the case of Lagged objects?
    expect_identical(.whichNativeLagged(new("Lagged1d")), "FlexibleLagged")
    expect_identical(.whichNativeLagged(new("Lagged2d")), "FlexibleLagged")
    expect_identical(.whichNativeLagged(new("Lagged3d")), "FlexibleLagged")

    expect_identical(.whichNativeLagged(new("Lagged3d")), "FlexibleLagged")

    ## otherwise
    expect_true(is.na(.whichNativeLagged(sin))) # a function
})
#+END_SRC

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
test_that("Lagged classes: initialisation",
{
    expect_equal_to_reference(new("FlexibleLagged"), "fl0.RDS")

    expect_equal(class( Lagged(data = new("Lagged1d")) ), "FlexibleLagged", FALSE)
    expect_equal(class( Lagged(data = new("Lagged2d")) ), "FlexibleLagged", FALSE)
    expect_equal(class( Lagged(data = new("Lagged3d")) ), "FlexibleLagged", FALSE)

    fl  <- new("FlexibleLagged", data = 1:3)
    fla <- new("FlexibleLagged", data = fl)
    expect_equal(class(fl@data), "Lagged1d", FALSE)
    expect_equal(class(fla@data), "Lagged1d", FALSE)
    expect_equal(fla@data, fl@data)
    expect_identical(fla@data, fl@data)

    acf_ap <- acf(AirPassengers, plot = FALSE)
    expect_identical(Lagged(acf_ap), acf2Lagged(acf_ap))

    ## cars is a data.frame
    expect_error(Lagged(cars), "I don't know how to create a Lagged object from the given data")

    z <- ts(matrix(rnorm(300), 100, 3), start = c(1961, 1), frequency = 12)
    acf2Lagged(acf(z))
    acf2Lagged(acf(z, type = "partial"))

})
#+END_SRC

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
test_that("dataWithLagNames() is ok",
{
    ## length-zero objects are returned as is
    expect_identical(dataWithLagNames(numeric(0)), numeric(0))
    m0 <- matrix(0, nrow = 0, ncol = 3)
    expect_identical(dataWithLagNames(m0), m0)

    expect_equal(dataWithLagNames(1:3), c(Lag_0 = 1, Lag_1 = 2,  Lag_2 =3))
    expect_equal(colnames(dataWithLagNames(matrix(1:12, nrow = 3))), paste0("Lag_", 0:3))

    a432 <- dataWithLagNames(array(1:24, dim = c(4,3,2)))
    expect_identical(dimnames(a432), list(rep("", 4), rep("", 3), c("Lag_0", "Lag_1")))
})
#+END_SRC

#+BEGIN_SRC R  :tangle ../tests/testthat/test-Lagged.R
test_that("Lagged: show",
{

    fl  <- new("FlexibleLagged", data = 1:3)
    expect_output(show(fl))


    expect_output(show(new("Lagged1d")))
    expect_output(show(new("Lagged2d")))
    expect_output(show(new("Lagged3d")))

})
#+END_SRC
